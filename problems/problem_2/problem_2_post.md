# Math and Ruby: Project Euler Problem 2

## Introduction

Today we are going to look at the second Project Euler problem! This one is focused on Fibonacci numbers. So it's a pretty classic problem. We are going to look at three approaches to solving this particular problem and the trade offs each one poses.

## Problem Statement

The following problem was taken from [Project Euler](https://projecteuler.net/problem=2):

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
> 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
> 
> By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

This is a cool little problem that is bounded to a relatively small set of integers. While we are only looking at Fibonacci numbers with a value of less than four million, we can still  have some performance issues and dig into how to address them.

## Breaking it down.

This problems has a three components. First, we need to generate a sequence of Fibonacci numbers. Second, we need to determine if that number is even. Lastly, we need to sum all those even numbers. 

## Some Math

Generating the Fibonacci sequence is a recursively defined sequence, so it lends itself to computing. We can use ruby's `.even?` function to determine if a given integer is even, but we will use the modulo operator. [The modulo operator](https://en.wikipedia.org/wiki/Modulo_operation) performs division and returns the *remainder*. That means if a number is divided by 2, and the remainder is 0, we know its even. 

For the last solution we are going to move away from the iterative approach and use [Binet's Formula](https://mathworld.wolfram.com/BinetsFibonacciNumberFormula.html), a function that can be used to directly calculate fibonacci numbers.

Two notes:

1. I begin my Fibonacci sequences with 0 and 1, while this doesn't strictly match problem statement, it won't cause any issues because we are not introducing any addition even numbers.
2. Each Method of fibonacci number generation generates the Nth term of the sequence, not the sequence itself. 

## Method One: Recursive Approach

```ruby
class ProblemTwoRecursive < ProblemBase
  MAX_VALUE = 4_000_000

  def self.result
    n = 0
    sum = 0

    while fibonacci(n) < MAX_VALUE
      sum += fibonacci(n) if fibonacci(n) % 2 == 0
      n += 1
    end

    sum
  end

  def self.fibonacci(n)
    return n if (0..1).include?(n)

    (fibonacci(n - 1) + fibonacci(n - 2))
  end
end
```

## Method Two: Iterative Approach

```ruby
class ProblemTwoIterative < ProblemBase
  MAX_VALUE = 4_000_000

  def self.result
    n = 0
    sum = 0

    while fibonacci(n) < MAX_VALUE
      sum += fibonacci(n) if fibonacci(n) % 2 == 0
      n += 1
    end

    sum
  end

  def self.fibonacci(n)
    fibonacci_terms = { 0 => 0, 1 => 1 }
    return fibonacci_terms[n] if fibonacci_terms.keys.include?(n)

    while fibonacci_terms.count <= n
      next_term = fibonacci_terms[fibonacci_terms.count - 1] + fibonacci_terms[fibonacci_terms.count - 2]
      next_key = fibonacci_terms.count

      fibonacci_terms.merge!(next_key => next_term)
    end

    fibonacci_terms[n]
  end
end
```

## Method Three: Binet's Formula

```ruby
# https://projecteuler.net/problem=2
class ProblemTwoDeclarative < ProblemBase
  MAX_VALUE = 4_000_000

  def self.result
    n = 0
    sum = 0

    while fibonacci(n) < MAX_VALUE
      sum += fibonacci(n) if fibonacci(n) % 2 == 0
      n += 1
    end

    sum
  end

  def self.fibonacci(n)
    puts "Binet's Formula is not accurate for n > 70" if n > 70

    sqrt5 = Math.sqrt(5)

    ((((1 + sqrt5)**n) - ((1 - sqrt5)**n)) / ((2**n) * sqrt5)).round
  end
end
```

# Comparing Methods

You can checkout the source code on [my GitHub](https://github.com/william-lawrence/math-and-ruby).
